# ui.py - User interface for DorkStrike PRO

import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox
import threading
import os
import requests
import csv
import json
import xml.etree.ElementTree as ET
from datetime import datetime
import time
from scanner import DorkScanner

class DorkStrikeUI:
    def __init__(self, root):
        self.root = root
        self.root.title("DorkStrike PRO - Продвинутый сканер Google Dork")
        self.root.geometry("1200x800")
        self.root.configure(bg='#2b2b2b')

        self.scanner = None
        self.scan_thread = None
        self.is_scanning = False

        # Category mapping Russian to English
        self.category_map = {
            "ВСЕ": "ALL",
            "КРИПТО": "CRYPTO",
            "СЕКРЕТЫ": "SECRETS",
            "УЯЗВИМОСТИ": "VULNERABILITIES"
        }

        self.setup_ui()
        self.load_config()
        self.proxy_check_timer = None
        self.start_proxy_check_timer()

    def setup_ui(self):
        # Create main frame
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Title
        title_label = ttk.Label(main_frame, text="DorkStrike PRO", font=("Arial", 24, "bold"))
        title_label.pack(pady=10)

        # Input frame
        input_frame = ttk.LabelFrame(main_frame, text="Конфигурация сканирования", padding=10)
        input_frame.pack(fill=tk.X, pady=5)

        # Domain input
        ttk.Label(input_frame, text="Целевой домен:").grid(row=0, column=0, sticky=tk.W, pady=2)
        self.domain_entry = ttk.Entry(input_frame, width=40)
        self.domain_entry.grid(row=0, column=1, padx=5, pady=2)

        # Load from file button
        self.load_file_button = ttk.Button(input_frame, text="Загрузить из файла", command=self.load_domains_from_file)
        self.load_file_button.grid(row=0, column=2, padx=5, pady=2)

        # Pattern category
        ttk.Label(input_frame, text="Категория паттернов:").grid(row=1, column=0, sticky=tk.W, pady=2)
        self.category_var = tk.StringVar(value="ВСЕ")
        category_combo = ttk.Combobox(input_frame, textvariable=self.category_var,
                                    values=["ВСЕ", "КРИПТО", "СЕКРЕТЫ", "УЯЗВИМОСТИ"], state="readonly")
        category_combo.grid(row=1, column=1, padx=5, pady=2)

        # Custom dork

        ttk.Label(input_frame, text="Пользовательский dork:").grid(row=2, column=0, sticky=tk.W, pady=2)

        self.custom_dork_text = scrolledtext.ScrolledText(input_frame, height=3, width=40)

        self.custom_dork_text.grid(row=2, column=1, padx=5, pady=2)

        # Local files

        ttk.Label(input_frame, text="Локальные файлы:").grid(row=3, column=0, sticky=tk.W, pady=2)

        self.local_files_entry = ttk.Entry(input_frame, width=40)

        self.local_files_entry.grid(row=3, column=1, padx=5, pady=2)
        # Concurrent Requests
        ttk.Label(input_frame, text="Максимум одновременных запросов:").grid(row=3, column=0, sticky=tk.W, pady=2)
        self.concurrent_var = tk.IntVar(value=50)
        concurrent_spin = ttk.Spinbox(input_frame, from_=1, to=200, textvariable=self.concurrent_var, width=10)
        concurrent_spin.grid(row=3, column=1, padx=5, pady=2)

        # Scanning depth
        ttk.Label(input_frame, text="Глубина сканирования:").grid(row=4, column=0, sticky=tk.W, pady=2)
        self.depth_var = tk.IntVar(value=3)
        depth_spin = ttk.Spinbox(input_frame, from_=1, to=10, textvariable=self.depth_var, width=10)
        depth_spin.grid(row=4, column=1, padx=5, pady=2)

        # Strictness level
        ttk.Label(input_frame, text="Строгость проверки:").grid(row=6, column=0, sticky=tk.W, pady=2)
        self.strictness_var = tk.StringVar(value="Средняя")
        strictness_combo = ttk.Combobox(input_frame, textvariable=self.strictness_var,
                                      values=["Легкая", "Средняя", "Тяжелая"], state="readonly")
        strictness_combo.grid(row=4, column=1, padx=5, pady=2)

        # Proxies
        ttk.Label(input_frame, text="Прокси (через запятую):").grid(row=5, column=0, sticky=tk.W, pady=2)
        self.proxy_entry = ttk.Entry(input_frame, width=50)
        self.proxy_entry.grid(row=5, column=1, padx=5, pady=2)

        # Search Engines
        ttk.Label(input_frame, text="Поисковые системы:").grid(row=6, column=0, sticky=tk.W, pady=2)
        self.engines_frame = ttk.Frame(input_frame)
        self.engines_frame.grid(row=6, column=1, padx=5, pady=2, sticky=tk.W)

        self.engine_vars = {}
        engines = ['google', 'duckduckgo', 'bing', 'shodan', 'wayback']
        engine_names = ['Google', 'DuckDuckGo', 'Bing', 'Shodan', 'Wayback']
        for i, (engine, name) in enumerate(zip(engines, engine_names)):
            var = tk.BooleanVar(value=(engine == 'google'))  # Default to Google
            self.engine_vars[engine] = var
            ttk.Checkbutton(self.engines_frame, text=name, variable=var).grid(row=0, column=i, padx=5)

        # JS Rendering
        ttk.Label(input_frame, text="JS рендеринг:").grid(row=7, column=0, sticky=tk.W, pady=2)
        self.js_rendering_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(input_frame, text="Включить headless браузер для динамических страниц", variable=self.js_rendering_var).grid(row=7, column=1, padx=5, pady=2, sticky=tk.W)

        # API Verification
        ttk.Label(input_frame, text="Проверка API:").grid(row=8, column=0, sticky=tk.W, pady=2)
        self.api_verify_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(input_frame, text="Проверять найденные API ключи живыми запросами", variable=self.api_verify_var).grid(row=8, column=1, padx=5, pady=2, sticky=tk.W)
 
        # Delay between requests
        ttk.Label(input_frame, text="Задержка между запросами (сек):").grid(row=9, column=0, sticky=tk.W, pady=2)
        self.delay_var = tk.DoubleVar(value=2.0)
        delay_spin = ttk.Spinbox(input_frame, from_=0, to=60, increment=0.5, textvariable=self.delay_var, width=10)
        delay_spin.grid(row=9, column=1, padx=5, pady=2)
        # Control buttons frame
        button_frame = ttk.Frame(input_frame)
        button_frame.grid(row=10, column=0, columnspan=3, pady=10)

        self.start_button = ttk.Button(button_frame, text="Начать сканирование", command=self.start_scan)
        self.start_button.pack(side=tk.LEFT, padx=5)

        self.stop_button = ttk.Button(button_frame, text="Остановить сканирование", command=self.stop_scan, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=5)

        self.clear_button = ttk.Button(button_frame, text="Очистить лог", command=self.clear_log)
        self.clear_button.pack(side=tk.LEFT, padx=5)

        self.export_button = ttk.Button(button_frame, text="Экспортировать результаты", command=self.export_results, state=tk.DISABLED)
        self.export_button.pack(side=tk.LEFT, padx=5)

        self.settings_button = ttk.Button(button_frame, text="Настройки", command=self.open_settings)
        self.settings_button.pack(side=tk.LEFT, padx=5)

        # Progress frame
        progress_frame = ttk.LabelFrame(main_frame, text="Прогресс", padding=10)
        progress_frame.pack(fill=tk.X, pady=5)

        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(progress_frame, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(fill=tk.X, pady=5)

        self.status_label = ttk.Label(progress_frame, text="Готов к сканированию")
        self.status_label.pack()

        # Results frame
        results_frame = ttk.LabelFrame(main_frame, text="Результаты", padding=10)
        results_frame.pack(fill=tk.BOTH, expand=True, pady=5)

        # Results notebook
        self.results_notebook = ttk.Notebook(results_frame)
        self.results_notebook.pack(fill=tk.BOTH, expand=True)

        # Findings tab
        findings_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(findings_frame, text="Найденные")

        self.findings_tree = ttk.Treeview(findings_frame, columns=("Type", "Pattern", "URL", "Match", "Verification"), show="headings")
        self.findings_tree.heading("Type", text="Тип")
        self.findings_tree.heading("Pattern", text="Паттерн")
        self.findings_tree.heading("URL", text="URL")
        self.findings_tree.heading("Match", text="Совпадение")
        self.findings_tree.heading("Verification", text="Проверка")
        self.findings_tree.column("Type", width=80)
        self.findings_tree.column("Pattern", width=120)
        self.findings_tree.column("URL", width=250)
        self.findings_tree.column("Match", width=150)
        self.findings_tree.column("Verification", width=150)

        findings_scrollbar = ttk.Scrollbar(findings_frame, orient=tk.VERTICAL, command=self.findings_tree.yview)
        self.findings_tree.configure(yscrollcommand=findings_scrollbar.set)

        self.findings_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        findings_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Log tab
        log_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(log_frame, text="Лог")

        self.log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, height=20)
        self.log_text.pack(fill=tk.BOTH, expand=True)

        # Statistics tab
        stats_frame = ttk.Frame(self.results_notebook)
        self.results_notebook.add(stats_frame, text="Статистика")

        # Statistics controls
        stats_controls = ttk.Frame(stats_frame)
        stats_controls.pack(fill=tk.X, pady=5)

        self.expand_stats_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(stats_controls, text="Показать подробную статистику", variable=self.expand_stats_var,
                       command=self.toggle_detailed_stats).pack(side=tk.LEFT, padx=5)

        self.stats_text = scrolledtext.ScrolledText(stats_frame, wrap=tk.WORD, height=20, state=tk.DISABLED)
        self.stats_text.pack(fill=tk.BOTH, expand=True)

        # Detailed stats (initially hidden)
        self.detailed_stats_frame = ttk.Frame(stats_frame)
        # Don't pack it initially - will be shown when expanded

        self.detailed_stats_text = scrolledtext.ScrolledText(self.detailed_stats_frame, wrap=tk.WORD, height=15, state=tk.DISABLED)
        self.detailed_stats_text.pack(fill=tk.BOTH, expand=True)

        # Initialize data
        self.findings_data = []
        self.scan_results = {}

    def start_scan(self):
        domain = self.domain_entry.get().strip()
        if not domain:
            messagebox.showerror("Ошибка", "Пожалуйста, введите целевой домен")
            return

        if not self.is_valid_domain(domain):
            messagebox.showerror("Ошибка", "Пожалуйста, введите корректный домен (например, example.com)")
            return

        self.is_scanning = True
        self.start_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        self.export_button.config(state=tk.DISABLED)
        self.clear_log()
        self.findings_data = []
        self.update_findings_tree()

        proxies_str = self.proxy_entry.get().strip()
        proxies = [p.strip() for p in proxies_str.split(',') if p.strip()] if proxies_str else []

        # Get selected search engines
        selected_engines = [engine for engine, var in self.engine_vars.items() if var.get()]

        self.scan_thread = threading.Thread(target=self.run_scan, args=(domain, proxies, selected_engines))
        self.scan_thread.start()

    def stop_scan(self):
        if self.scanner:
            self.scanner.stop_scan()
        self.is_scanning = False
        self.status_label.config(text="Сканирование остановлено")
        self.start_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)

    def run_scan(self, domain, proxies, search_engines):
        try:
            self.log_message(f"Начинаем сканирование домена: {domain}")
            self.status_label.config(text="Сканирование...")

            # Map Russian strictness to English
            strictness_map = {"Легкая": "light", "Средняя": "medium", "Тяжелая": "heavy"}
            strictness = strictness_map.get(self.strictness_var.get(), "medium")
 
            self.scanner = DorkScanner(
                proxies,
                search_engines,
                self.js_rendering_var.get(),
                self.api_verify_var.get(),
                strictness,
                self.depth_var.get(),
                self.delay_var.get()
            )

            results = self.scanner.scan(
                domain,
                self.category_map.get(self.category_var.get(), "ALL"),
                self.concurrent_var.get(),
                self.update_progress,
                self.log_message,
                self.add_finding
            )

            self.scan_results = results
            self.display_statistics(results)

            self.root.after(0, lambda: self.export_button.config(state=tk.NORMAL))
            self.log_message("Сканирование завершено успешно")

        except Exception as e:
            self.log_message(f"Сканирование не удалось: {str(e)}")
        finally:
            self.is_scanning = False
            self.root.after(0, lambda: self.start_button.config(state=tk.NORMAL))
            self.root.after(0, lambda: self.stop_button.config(state=tk.DISABLED))
            self.root.after(0, lambda: self.status_label.config(text="Сканирование завершено"))

    def update_progress(self, progress):
        self.root.after(0, lambda: self.progress_var.set(progress))

    def log_message(self, message):
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.root.after(0, lambda: self.log_text.insert(tk.END, f"[{timestamp}] {message}\n"))
        self.root.after(0, lambda: self.log_text.see(tk.END))

    def add_finding(self, finding_type, pattern, url, match, verification="Format valid"):
        finding = {
            'type': finding_type,
            'pattern': pattern,
            'url': url,
            'match': match,
            'verification': verification
        }
        self.findings_data.append(finding)
        self.root.after(0, self.update_findings_tree)

    def update_findings_tree(self):
        for item in self.findings_tree.get_children():
            self.findings_tree.delete(item)

        for finding in self.findings_data:
            self.findings_tree.insert("", tk.END, values=(
                finding['type'],
                finding['pattern'],
                finding['url'],
                finding['match'],
                finding.get('verification', 'Format valid')
            ))

    def display_statistics(self, results):
        stats = f"""Статистика сканирования:

    Всего просканировано URL: {results['total_urls']}
    Всего найденных: {results['findings_count']}
    Длительность сканирования: {results['duration']:.2f} секунд
    Среднее время ответа: {results['avg_response_time']:.2f} секунд

    Классификация ресурсов (Категории):
    """

        # Add resource classification statistics
        resource_stats = results.get('resource_stats', {})
        category_descriptions = {
            'A': 'CONFIG/DATA FILES (КРИТИЧНО)',
            'B': 'SOURCE/BUILD ARTIFACTS (ВЫСОКО)',
            'C': 'BACKUPS/DUMPS (ВЫСОКО)',
            'D': 'WEB PAGES (НИЗКО)',
            'E': 'DOCS (ПРОПУЩЕНО)'
        }

        for cat in ['A', 'B', 'C', 'D', 'E']:
            count = resource_stats.get(cat, 0)
            stats += f"  {cat}: {category_descriptions[cat]} - {count}\n"

        stats += "\nРазбивка по паттернам:\n"

        for pattern, count in results['pattern_breakdown'].items():
            stats += f"{pattern}: {count}\n"

        self.root.after(0, lambda: self.stats_text.config(state=tk.NORMAL))
        self.root.after(0, lambda: self.stats_text.delete(1.0, tk.END))
        self.root.after(0, lambda: self.stats_text.insert(tk.END, stats))
        self.root.after(0, lambda: self.stats_text.config(state=tk.DISABLED))

        # Update detailed stats if expanded
        if self.expand_stats_var.get():
            self.update_detailed_stats(results)

    def clear_log(self):
        self.log_text.delete(1.0, tk.END)
        self.findings_data = []
        self.update_findings_tree()
        self.stats_text.config(state=tk.NORMAL)
        self.stats_text.delete(1.0, tk.END)
        self.stats_text.config(state=tk.DISABLED)
        self.progress_var.set(0)
        self.status_label.config(text="Готов к сканированию")

    def export_results(self):
        if not self.findings_data:
            messagebox.showwarning("Предупреждение", "Нет результатов для экспорта")
            return

        file_types = [
            ("CSV файлы", "*.csv"),
            ("JSON файлы", "*.json"),
            ("XML файлы", "*.xml"),
            ("Текстовые файлы", "*.txt")
        ]

        filename = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=file_types,
            title="Экспортировать результаты"
        )

        if filename:
            try:
                if filename.endswith('.csv'):
                    self.export_csv(filename)
                elif filename.endswith('.json'):
                    self.export_json(filename)
                elif filename.endswith('.xml'):
                    self.export_xml(filename)
                else:
                    self.export_txt(filename)

                messagebox.showinfo("Успех", f"Результаты экспортированы в {filename}")
            except Exception as e:
                messagebox.showerror("Ошибка", f"Не удалось экспортировать результаты: {str(e)}")

    def export_csv(self, filename):
        with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ['Type', 'Pattern', 'URL', 'Match', 'Verification']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            for finding in self.findings_data:
                writer.writerow({
                    'Type': finding['type'],
                    'Pattern': finding['pattern'],
                    'URL': finding['url'],
                    'Match': finding['match'],
                    'Verification': finding.get('verification', 'Format valid')
                })

    def export_json(self, filename):
        with open(filename, 'w', encoding='utf-8') as jsonfile:
            json.dump({
                'scan_results': self.scan_results,
                'findings': self.findings_data
            }, jsonfile, indent=2)

    def export_xml(self, filename):
        root = ET.Element("DorkStrikeResults")
        scan_info = ET.SubElement(root, "ScanInfo")
        ET.SubElement(scan_info, "TotalURLs").text = str(self.scan_results.get('total_urls', 0))
        ET.SubElement(scan_info, "FindingsCount").text = str(self.scan_results.get('findings_count', 0))
        ET.SubElement(scan_info, "Duration").text = str(self.scan_results.get('duration', 0))

        findings_elem = ET.SubElement(root, "Findings")
        for finding in self.findings_data:
            finding_elem = ET.SubElement(findings_elem, "Finding")
            ET.SubElement(finding_elem, "Type").text = finding['type']
            ET.SubElement(finding_elem, "Pattern").text = finding['pattern']
            ET.SubElement(finding_elem, "URL").text = finding['url']
            ET.SubElement(finding_elem, "Match").text = finding['match']
            ET.SubElement(finding_elem, "Verification").text = finding.get('verification', 'Format valid')

        tree = ET.ElementTree(root)
        tree.write(filename, encoding='utf-8', xml_declaration=True)

    def export_txt(self, filename):
        with open(filename, 'w', encoding='utf-8') as txtfile:
            txtfile.write("Результаты сканирования DorkStrike PRO\n")
            txtfile.write("=" * 50 + "\n\n")
            txtfile.write(f"Всего просканировано URL: {self.scan_results.get('total_urls', 0)}\n")
            txtfile.write(f"Всего найденных: {self.scan_results.get('findings_count', 0)}\n")
            txtfile.write(f"Длительность сканирования: {self.scan_results.get('duration', 0):.2f} секунд\n\n")

            txtfile.write("Найденные:\n")
            txtfile.write("-" * 30 + "\n")
            for finding in self.findings_data:
                txtfile.write(f"Тип: {finding['type']}\n")
                txtfile.write(f"Паттерн: {finding['pattern']}\n")
                txtfile.write(f"URL: {finding['url']}\n")
                txtfile.write(f"Совпадение: {finding['match']}\n")
                txtfile.write(f"Проверка: {finding.get('verification', 'Format valid')}\n\n")

    def open_settings(self):
        # Placeholder for settings dialog
        messagebox.showinfo("Настройки", "Диалог настроек пока не реализован")

    def load_domains_from_file(self):
        """Load domains from a text file"""
        file_types = [("Text files", "*.txt"), ("All files", "*.*")]
        filename = filedialog.askopenfilename(
            title="Выберите файл с доменами",
            filetypes=file_types
        )

        if filename:
            try:
                with open(filename, 'r', encoding='utf-8') as f:
                    domains = [line.strip() for line in f if line.strip() and not line.startswith('#')]
                    if domains:
                        # Join domains with commas for the entry field
                        self.domain_entry.delete(0, tk.END)
                        self.domain_entry.insert(0, ', '.join(domains))
                        messagebox.showinfo("Успех", f"Загружено {len(domains)} доменов из файла")
                    else:
                        messagebox.showwarning("Предупреждение", "Файл не содержит допустимых доменов")
            except Exception as e:
                messagebox.showerror("Ошибка", f"Не удалось загрузить файл: {str(e)}")

    def is_valid_domain(self, domain):
        # Basic domain validation
        import re
        pattern = r'^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$'
        return re.match(pattern, domain) is not None

    def load_config(self):
        # Load configuration (placeholder)
        pass

    def save_config(self):
        # Save configuration (placeholder)
        pass

    def toggle_detailed_stats(self):
        if self.expand_stats_var.get():
            self.detailed_stats_frame.pack(fill=tk.BOTH, expand=True)
        else:
            self.detailed_stats_frame.pack_forget()

    def update_detailed_stats(self, results):
        detailed = f"Подробная статистика:\n\n"
        detailed += f"Общее время: {results['duration']:.2f} сек\n"
        detailed += f"Среднее время ответа: {results['avg_response_time']:.2f} сек\n\n"

        # Add resource classification breakdown
        detailed += "Распределение по категориям ресурсов:\n"
        resource_stats = results.get('resource_stats', {})
        total_resources = sum(resource_stats.values())

        if total_resources > 0:
            for cat in ['A', 'B', 'C', 'D', 'E']:
                count = resource_stats.get(cat, 0)
                percentage = (count / total_resources) * 100
                detailed += f"  {cat}: {count} ({percentage:.1f}%)\n"
        else:
            detailed += "  Нет данных\n"

        self.root.after(0, lambda: self.detailed_stats_text.config(state=tk.NORMAL))
        self.root.after(0, lambda: self.detailed_stats_text.delete(1.0, tk.END))
        self.root.after(0, lambda: self.detailed_stats_text.insert(tk.END, detailed))
        self.root.after(0, lambda: self.detailed_stats_text.config(state=tk.DISABLED))

    def start_proxy_check_timer(self):

        if self.proxy_check_timer:

            self.proxy_check_timer.cancel()

        self.proxy_check_timer = threading.Timer(900, self.auto_check_proxies)

        self.proxy_check_timer.start()

    def auto_check_proxies(self):

        self.check_proxies()

        self.start_proxy_check_timer()

    def check_proxies(self):

        proxies_str = self.proxy_entry.get().strip()

        if not proxies_str:

            return

        proxies = [p.strip() for p in proxies_str.split(',') if p.strip()]

        valid_proxies = []

        for proxy in proxies:

            if self.is_proxy_valid(proxy):

                valid_proxies.append(proxy)

            else:

                self.log_message(f"Удален недействительный прокси: {proxy}")

        if len(valid_proxies) != len(proxies):

            self.proxy_entry.delete(0, tk.END)

            self.proxy_entry.insert(0, ', '.join(valid_proxies))

            self.log_message(f"Проверка прокси завершена. Осталось {len(valid_proxies)} из {len(proxies)}")

    def is_proxy_valid(self, proxy):

        try:

            response = requests.get('http://httpbin.org/ip', proxies={'http': proxy, 'https': proxy}, timeout=5)

            return response.status_code == 200

        except:

            return False

    def load_proxies_from_file(self):

        file_types = [("Text files", "*.txt"), ("All files", "*.*")]

        filename = filedialog.askopenfilename(

            title="Выберите файл с прокси",

            filetypes=file_types

        )

        if filename:

            try:

                with open(filename, 'r', encoding='utf-8') as f:

                    proxies = [line.strip() for line in f if line.strip() and not line.startswith('#')]

                    if proxies:

                        proxy_type = self.proxy_type_var.get().lower()

                        formatted_proxies = [f"{proxy_type}://{p}" for p in proxies]

                        self.proxy_entry.delete(0, tk.END)

                        self.proxy_entry.insert(0, ', '.join(formatted_proxies))

                        messagebox.showinfo("Успех", f"Загружено {len(proxies)} прокси из файла")

                    else:

                        messagebox.showwarning("Предупреждение", "Файл не содержит допустимых прокси")

            except Exception as e:

                messagebox.showerror("Ошибка", f"Не удалось загрузить файл: {str(e)}")

def main():
    root = tk.Tk()
    app = DorkStrikeUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
